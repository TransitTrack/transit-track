package org.transitclock.config.data;

import org.transitclock.config.IntegerConfigValue;
import org.transitclock.utils.Time;

public class ArrivalsDeparturesConfig {
//    public static IntegerConfigValue maxStopsWhenNoPreviousMatch = new IntegerConfigValue(
//            "transitclock.arrivalsDepartures.maxStopsWhenNoPreviousMatch",
//            1,
//            "If vehicle just became predictable as indicated by no "
//                    + "previous match then still want to determine "
//                    + "arrival/departure times for earlier stops so that won't "
//                    + "miss recording data for them them. But only want to go "
//                    + "so far. Otherwise could be generating fake "
//                    + "arrival/departure times when vehicle did not actually "
//                    + "traverse that stop.");
//
//    public static IntegerConfigValue maxStopsBetweenMatches = new IntegerConfigValue(
//            "transitclock.arrivalsDepartures.maxStopsBetweenMatches",
//            12,
//            "If between AVL reports the vehicle appears to traverse "
//                    + "many stops then something is likely wrong with the "
//                    + "matching. So this parameter is used to limit how many "
//                    + "arrivals/departures are created between AVL reports.");
//
//    public static IntegerConfigValue allowableDifferenceBetweenAvlTimeSecs = new IntegerConfigValue(
//            "transitclock.arrivalsDepartures.allowableDifferenceBetweenAvlTimeSecs",
//            // Default is to only log problem if arrival time is more
//            // than a day off
//            Time.SEC_PER_DAY,
//            "If the time of a determine arrival/departure is really "
//                    + "different from the AVL time then something must be "
//                    + "wrong and the situation will be logged.");
}
