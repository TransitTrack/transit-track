/* (C)2023 */
package org.transitclock.domain.structs;

import java.io.Serializable;
import java.util.Date;
import java.util.Objects;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.hibernate.annotations.DynamicUpdate;
import org.transitclock.service.dto.IpcPrediction;

/**
 * For persisting a prediction.
 *
 * @author SkiBu Smith
 */
@Entity
@DynamicUpdate
@Setter @Getter @ToString
@Table(
    name = "predictions",
    indexes = {@Index(name = "PredictionTimeIndex", columnList = "creation_time")}
)
public class Prediction implements Serializable {

    // Need an ID but using a regular column doesn't really make
    // sense. So use an auto generated one. Not final since
    // autogenerated and therefore not set in constructor.
    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    // The revision of the configuration data that was being used
    @Column(name = "config_rev")
    private final int configRev;

    @Column(name = "prediction_time")
    @Temporal(TemporalType.TIMESTAMP)
    private final Date predictionTime;

    // Timestamp of the AVL report that caused the prediction to be generated
    @Column(name = "avl_time")
    @Temporal(TemporalType.TIMESTAMP)
    private final Date avlTime;

    // The time the AVL data was processed and the prediction was created.
    @Column(name = "creation_time")
    @Temporal(TemporalType.TIMESTAMP)
    private final Date creationTime;

    @Column(name = "vehicle_id", length = 60)
    private final String vehicleId;

    @Column(name = "stop_id", length = 60)
    private final String stopId;

    @Column(name = "trip_id", length = 60)
    private final String tripId;

    @Column(name = "route_id", length = 60)
    private final String routeId;

    @Column(name = "affected_by_wait_stop")
    private final boolean affectedByWaitStop;

    @Column(name = "is_arrival")
    private final boolean isArrival;

    @Column(name = "is_schedule_based_prediction")
    private final boolean schedBasedPred;

    @Column(name = "gtfs_stop_sequence")
    private final int gtfsStopSeq;

    public Prediction(int configRev, IpcPrediction prediction) {
        this.configRev = configRev;
        this.predictionTime = new Date(prediction.getPredictionTime());
        this.avlTime = new Date(prediction.getAvlTime());
        this.creationTime = new Date(prediction.getCreationTime());
        this.vehicleId = prediction.getVehicleId();
        this.stopId = prediction.getStopId();
        this.tripId = prediction.getTripId();
        this.routeId = prediction.getTrip().getRouteId();
        this.affectedByWaitStop = prediction.isAffectedByWaitStop();
        this.isArrival = prediction.isArrival();
        this.schedBasedPred = prediction.isSchedBasedPred();
        this.gtfsStopSeq = prediction.getGtfsStopSeq();
    }

    /** Hibernate requires a no-arg constructor for reading objects from database. */
    protected Prediction() {
        this.configRev = -1;
        this.predictionTime = null;
        this.avlTime = null;
        this.creationTime = null;
        this.vehicleId = null;
        this.stopId = null;
        this.tripId = null;
        this.routeId = null;
        this.affectedByWaitStop = false;
        this.isArrival = false;
        this.schedBasedPred = false;
        this.gtfsStopSeq = -1;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Prediction that)) return false;
        return id == that.id && configRev == that.configRev && affectedByWaitStop == that.affectedByWaitStop && isArrival == that.isArrival && schedBasedPred == that.schedBasedPred && gtfsStopSeq == that.gtfsStopSeq && Objects.equals(predictionTime, that.predictionTime) && Objects.equals(avlTime, that.avlTime) && Objects.equals(creationTime, that.creationTime) && Objects.equals(vehicleId, that.vehicleId) && Objects.equals(stopId, that.stopId) && Objects.equals(tripId, that.tripId) && Objects.equals(routeId, that.routeId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, configRev, predictionTime, avlTime, creationTime, vehicleId, stopId, tripId, routeId, affectedByWaitStop, isArrival, schedBasedPred, gtfsStopSeq);
    }
}
